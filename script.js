// Configuration mapping - maps form input names to CSS custom properties
const radiusMapping = {
    'radiusXl': '--radius-xl',
    'radiusLg': '--radius-lg',
    'radiusMd': '--radius-md',
    'radiusSm': '--radius-sm',
    'radiusXs': '--radius-xs',
    'radiusMin': '--radius-min'
};

const colorMapping = {
    'colorBlack': '--color-black',
    'colorWhite': '--color-white',
    'colorDark': '--color-dark',
    'colorLight': '--color-light',
    'colorPrimary': '--color-primary',
    'colorSecondary': '--color-secondary'
};

const fontMapping = {
    'fontBody': '--font-body',
    'fontHeadings': '--font-headings'
};

// Counter for custom color IDs
let customColorCounter = 0;

// Store generated config
let generatedConfig = '';

// Initialize app
document.addEventListener('DOMContentLoaded', function() {
    const generateBtn = document.getElementById('generateBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const addColorBtn = document.getElementById('addColorBtn');
    const addFontSizeBtn = document.getElementById('addFontSizeBtn');

    generateBtn.addEventListener('click', generateConfig);
    downloadBtn.addEventListener('click', downloadConfig);
    addColorBtn.addEventListener('click', addCustomColor);
    addFontSizeBtn.addEventListener('click', showNextFontSize);
});

// Helper function to format numbers (removes trailing .0 and handles zero)
function formatNumber(num) {
    if (num === 0) return '0';
    return parseFloat(num).toString();
}

// Generate Tailwind config from form inputs
function generateConfig() {
    const form = document.getElementById('configForm');
    const formData = new FormData(form);

    // Start building the config file content
    let configContent = '/* Tailwind CSS Configuration */\n';
    configContent += '/* Generated by TW Config Generator */\n\n';
    configContent += '@theme {\n';

    // Colors Section
    configContent += '  /* Colors */\n';

    // Process default colors
    for (const [inputName, cssProperty] of Object.entries(colorMapping)) {
        const value = formData.get(inputName);
        if (value && value.trim() !== '') {
            configContent += `  ${cssProperty}: ${value};\n`;
        }
    }

    // Process custom colors
    const customColorItems = document.querySelectorAll('.custom-color-item');
    customColorItems.forEach(item => {
        const nameInput = item.querySelector('input[type="text"]');
        const colorInput = item.querySelector('input[type="color"]');

        if (nameInput && colorInput && nameInput.value.trim() !== '') {
            const colorName = nameInput.value.trim().toLowerCase().replace(/\s+/g, '-');
            configContent += `  --color-${colorName}: ${colorInput.value};\n`;
        }
    });

    // Always add transparent
    configContent += '  --color-transparent: transparent;\n\n';

    // Font Family Section
    configContent += '  /* Font Family */\n';
    const fontBody = formData.get('fontBody');
    const fontHeadings = formData.get('fontHeadings');

    if (fontBody && fontBody.trim() !== '') {
        configContent += `  --font-body:\n    ${fontBody};\n`;
    }

    if (fontHeadings && fontHeadings.trim() !== '') {
        configContent += `  --font-headings:\n    ${fontHeadings};\n`;
    }

    configContent += '\n';

    // Font Sizes Section
    const fontSizes = [];
    for (let i = 1; i <= 10; i++) {
        const size = formData.get(`fontSize${i}Size`);
        const weight = formData.get(`fontSize${i}Weight`);
        const lineHeight = formData.get(`fontSize${i}LineHeight`);
        const letterSpacing = formData.get(`fontSize${i}LetterSpacing`);

        if (size && size.trim() !== '') {
            fontSizes.push({
                px: parseFloat(size),
                weight: weight && weight.trim() !== '' ? weight : null,
                lineHeight: lineHeight && lineHeight.trim() !== '' ? lineHeight : null,
                letterSpacing: letterSpacing && letterSpacing.trim() !== '' ? letterSpacing : null
            });
        }
    }

    if (fontSizes.length > 0) {
        // Sort by size, largest first
        fontSizes.sort((a, b) => b.px - a.px);

        // Find scalable sizes (> 16px) for proportional scaling
        const scalableSizes = fontSizes.filter(fs => fs.px > 16).map(fs => fs.px);
        const maxSize = scalableSizes.length > 0 ? Math.max(...scalableSizes) : 0;
        const minSize = scalableSizes.length > 0 ? Math.min(...scalableSizes) : 0;
        const sizeRange = maxSize - minSize;

        configContent += '  /* Font Sizes */\n';

        fontSizes.forEach((fs, index) => {
            const { px, weight, lineHeight, letterSpacing } = fs;

            // Calculate vw value (px as percentage of 1920)
            const vwValue = ((px / 1920) * 100);
            const vw = formatNumber(parseFloat(vwValue.toFixed(2)));

            // Calculate rem value
            let remValue;
            if (px <= 16) {
                // For sizes 16px and below, use standard conversion
                remValue = px / 10;
            } else {
                // Scale proportionally between 1.8rem and 5rem
                if (sizeRange > 0) {
                    const position = (px - minSize) / sizeRange;
                    remValue = 1.8 + (5 - 1.8) * position;
                } else {
                    // Only one size > 16px, use 5rem
                    remValue = 5;
                }
            }
            const rem = formatNumber(parseFloat(remValue.toFixed(2)));

            // Output the font size variable with comment
            configContent += `  /* ${px}px */\n`;
            configContent += `  --text-${index}: max(${rem}rem, ${vw}vw);\n`;

            // Output optional properties
            if (weight) {
                configContent += `  --text-${index}--font-weight: ${weight};\n`;
            }
            if (lineHeight) {
                configContent += `  --text-${index}--line-height: ${lineHeight};\n`;
            }
            if (letterSpacing) {
                configContent += `  --text-${index}--letter-spacing: ${letterSpacing};\n`;
            }

            // Add blank line between font size entries
            if (index < fontSizes.length - 1) {
                configContent += '\n';
            }
        });

        configContent += '\n';
    }

    // Spacing Section
    configContent += '  /* Spacing */\n';

    const spacingGutter = formData.get('spacingGutter');
    const gutterValue = spacingGutter ? parseFloat(spacingGutter) / 10 : 3;
    const gutterRem = formatNumber(gutterValue);
    const gutterUnit = gutterRem === '0' ? '' : 'rem';

    const spacingMapping = {
        'spacingXl': '--spacing-xl',
        'spacingLg': '--spacing-lg',
        'spacingMd': '--spacing-md',
        'spacingSm': '--spacing-sm',
        'spacingXs': '--spacing-xs',
        'spacingMin': '--spacing-min'
    };

    for (const [inputName, cssProperty] of Object.entries(spacingMapping)) {
        const value = formData.get(inputName);
        if (value && value.trim() !== '') {
            const px = parseFloat(value);
            const vwValue = ((px / 1920) * 100);
            const vw = formatNumber(parseFloat(vwValue.toFixed(2)));
            configContent += `  ${cssProperty}: max(${gutterRem}${gutterUnit}, ${vw}vw); /* ${px}px */\n`;
        }
    }

    configContent += '  --spacing-full: 100%;\n\n';

    // Container Gap Section
    configContent += '  /* Container */\n';
    const gutterHalf = formatNumber(gutterValue / 2);
    const gutterTwoThirds = formatNumber(parseFloat((gutterValue * 2 / 3).toFixed(3)));
    const gutterThreeQuarters = formatNumber(parseFloat((gutterValue * 3 / 4).toFixed(3)));

    const halfUnit = gutterHalf === '0' ? '' : 'rem';
    const twoThirdsUnit = gutterTwoThirds === '0' ? '' : 'rem';
    const threeQuartersUnit = gutterThreeQuarters === '0' ? '' : 'rem';

    configContent += `  --container-gap-half: calc(50% - ${gutterHalf}${halfUnit});\n`;
    configContent += `  --container-gap-third: calc(33.333% - ${gutterTwoThirds}${twoThirdsUnit});\n`;
    configContent += `  --container-gap-quarter: calc(25% - ${gutterThreeQuarters}${threeQuartersUnit});\n\n`;

    // Border Radius Section
    configContent += '  /* Border Radius */\n';
    for (const [inputName, cssProperty] of Object.entries(radiusMapping)) {
        const value = formData.get(inputName);
        if (value && value.trim() !== '') {
            // Convert px to rem (divide by 10)
            const remValue = parseFloat(value) / 10;
            const formatted = formatNumber(remValue);
            const unit = formatted === '0' ? '' : 'rem';
            configContent += `  ${cssProperty}: ${formatted}${unit};\n`;
        }
    }
    configContent += '  --radius-full: 9999px;\n\n';

    // Breakpoints Section (static values)
    configContent += '  /* Breakpoints */\n';
    configContent += '  --breakpoint-xs: 370px;\n';
    configContent += '  --breakpoint-sm: 600px;\n';
    configContent += '  --breakpoint-md: 900px;\n';
    configContent += '  --breakpoint-lg: 1200px;\n';
    configContent += '  --breakpoint-xl: 1800px;\n';
    configContent += '  --breakpoint-2xl: 2200px;\n';
    configContent += '  --breakpoint-uhd: 3000px;\n\n';

    // Tracking Section (static values)
    configContent += '  /* Tracking */\n';
    configContent += '  --tracking-xs: 0.01em;\n';
    configContent += '  --tracking-sm: 0.02em;\n';
    configContent += '  --tracking-md: 0.03em;\n';
    configContent += '  --tracking-lg: 0.04em;\n';
    configContent += '  --tracking-xl: 0.05em;\n\n';

    // Transition Section (static values)
    configContent += '  /* Transition */\n';
    configContent += '  --default-transition-duration: 250ms;\n';

    configContent += '}\n\n';

    // Utility Classes
    configContent += '/* Aspect Ratio Utility */\n';
    configContent += '@utility aspect-* {\n';
    configContent += '  aspect-ratio: --value(ratio, [ratio]);\n';
    configContent += '}\n\n';

    configContent += '/* Margin Utilities */\n';
    configContent += '@utility mt-* {\n';
    configContent += '  margin-top: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility -mt-* {\n';
    configContent += '  margin-top: calc(--value(ratio) * -100%);\n';
    configContent += '}\n\n';

    configContent += '@utility mr-* {\n';
    configContent += '  margin-right: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility mb-* {\n';
    configContent += '  margin-bottom: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility -mb-* {\n';
    configContent += '  margin-bottom: calc(--value(ratio) * -100%);\n';
    configContent += '}\n\n';

    configContent += '@utility ml-* {\n';
    configContent += '  margin-left: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility mx-* {\n';
    configContent += '  margin-inline: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility my-* {\n';
    configContent += '  margin-block: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '/* Padding Utilities */\n';
    configContent += '@utility pt-* {\n';
    configContent += '  padding-top: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility pr-* {\n';
    configContent += '  padding-right: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility pb-* {\n';
    configContent += '  padding-bottom: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility pl-* {\n';
    configContent += '  padding-left: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility px-* {\n';
    configContent += '  padding-inline: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    configContent += '@utility py-* {\n';
    configContent += '  padding-block: calc(--value(ratio) * 100%);\n';
    configContent += '}\n\n';

    // Container Utility
    const containerMargin = formData.get('containerMargin');
    const containerMarginPx = containerMargin ? parseFloat(containerMargin) : 100;
    const containerWidthValue = (((1920 - (containerMarginPx * 2)) / 1920) * 100);
    const containerWidthPercent = formatNumber(parseFloat(containerWidthValue.toFixed(2)));

    configContent += '/* Container Utility */\n';
    configContent += '@utility container {\n';
    configContent += '  position: relative;\n';
    configContent += '  z-index: 10;\n';
    configContent += '  margin-inline: auto;\n';
    configContent += '  padding-inline: 0;\n';
    configContent += `  width: calc(100% - ${gutterRem}${gutterUnit}) !important;\n`;
    configContent += '  max-width: unset;\n';
    configContent += `  @apply max-w-none! sm:w-[${containerWidthPercent}%]!;\n`;
    configContent += '}\n';

    // Store the generated config
    generatedConfig = configContent;

    // Update preview
    updatePreview(configContent);

    // Enable download button
    document.getElementById('downloadBtn').disabled = false;
}

// Update the preview area
function updatePreview(content) {
    const previewElement = document.getElementById('configPreview');
    previewElement.innerHTML = `<code>${escapeHtml(content)}</code>`;
}

// Escape HTML for display
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Download the generated config file
function downloadConfig() {
    if (!generatedConfig) {
        alert('Please generate a config first!');
        return;
    }

    // Create blob and download link
    const blob = new Blob([generatedConfig], { type: 'text/css' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');

    link.href = url;
    link.download = '_tw.css';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

// Add a custom color input
function addCustomColor() {
    const container = document.getElementById('customColorsContainer');
    const colorId = `custom-color-${customColorCounter++}`;

    // Create custom color item
    const colorItem = document.createElement('div');
    colorItem.className = 'custom-color-item';
    colorItem.dataset.colorId = colorId;

    // Create name input group
    const nameGroup = document.createElement('div');
    nameGroup.className = 'form-group';

    const nameLabel = document.createElement('label');
    nameLabel.htmlFor = `${colorId}-name`;
    nameLabel.textContent = 'Color Name:';

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.id = `${colorId}-name`;
    nameInput.name = `${colorId}-name`;
    nameInput.placeholder = 'e.g., accent, success, danger';

    nameGroup.appendChild(nameLabel);
    nameGroup.appendChild(nameInput);

    // Create color input group
    const colorGroup = document.createElement('div');
    colorGroup.className = 'form-group';

    const colorLabel = document.createElement('label');
    colorLabel.htmlFor = `${colorId}-value`;
    colorLabel.textContent = 'Color Value:';

    const colorInput = document.createElement('input');
    colorInput.type = 'color';
    colorInput.id = `${colorId}-value`;
    colorInput.name = `${colorId}-value`;
    colorInput.value = '#667eea';

    colorGroup.appendChild(colorLabel);
    colorGroup.appendChild(colorInput);

    // Create remove button
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn-remove';
    removeBtn.textContent = 'Remove';
    removeBtn.onclick = function() {
        removeCustomColor(colorId);
    };

    // Assemble the color item
    colorItem.appendChild(nameGroup);
    colorItem.appendChild(colorGroup);
    colorItem.appendChild(removeBtn);

    // Add to container
    container.appendChild(colorItem);
}

// Remove a custom color input
function removeCustomColor(colorId) {
    const colorItem = document.querySelector(`[data-color-id="${colorId}"]`);
    if (colorItem) {
        colorItem.remove();
    }
}

// Show the next hidden font size group
function showNextFontSize() {
    const fontSizeItems = document.querySelectorAll('.font-size-item');
    const hiddenItems = Array.from(fontSizeItems).filter(item => item.classList.contains('hidden'));

    if (hiddenItems.length > 0) {
        // Show the first hidden item
        hiddenItems[0].classList.remove('hidden');

        // If no more hidden items, hide the button
        if (hiddenItems.length === 1) {
            document.getElementById('addFontSizeBtn').style.display = 'none';
        }
    }
}

// Helper function to add form inputs dynamically (you'll customize this based on your needs)
function addFormInput(container, config) {
    const formGroup = document.createElement('div');
    formGroup.className = 'form-group';

    const label = document.createElement('label');
    label.htmlFor = config.id;
    label.textContent = config.label;

    let input;
    if (config.type === 'select') {
        input = document.createElement('select');
        config.options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.label;
            input.appendChild(option);
        });
    } else if (config.type === 'textarea') {
        input = document.createElement('textarea');
        input.rows = config.rows || 4;
    } else {
        input = document.createElement('input');
        input.type = config.type || 'text';
    }

    input.id = config.id;
    input.name = config.name;
    input.placeholder = config.placeholder || '';

    if (config.value) {
        input.value = config.value;
    }

    formGroup.appendChild(label);
    formGroup.appendChild(input);

    if (config.helpText) {
        const helpText = document.createElement('span');
        helpText.className = 'help-text';
        helpText.textContent = config.helpText;
        formGroup.appendChild(helpText);
    }

    container.appendChild(formGroup);
}
